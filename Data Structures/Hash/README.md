# Hash(해시)

Hash Table(해시 테이블)은 key와 value를 Hash Function(해시 함수)를 이용하여 매핑해둔 자료 구조이다.

해시 함수를 이용해 얻은 고유한 인덱스로 배열에 저장해서, 검색에 평균적으로 시간 복잡도 O(1)을 갖는다.

## Hash Collision(해시 충돌)

데이터가 많아지면, 다른 데이터가 같은 해시 값으로 충돌이 나며, 검색 속도가 느려진다.

그럼에도 해시 테이블을 사용하는 이유는

- 적은 자원으로 많은 데이터를 효율적으로 관리할 수 있다.

- 하드 디스크나 클라우드에 존재하는 무한한 데이터들을 유한한 개수의 해시 값으로 매핑하여 작은 메모리로도 프로세스 관리가 가능해진다.

## 충돌 해결 방법

C++와 Java는 Separate Chaining 이용하고, Python은 Open Addressing 이용한다고 알려져있다.

### 1. Separate Chaining(분리 연결법)

해시 버킷(데이터를 저장할 공간)에 Linked List나 Red-Black Tree를 이용하는 방식이다.

데이터 개수가 적을 때(6 이하)는 Linked List가 효율적이고, 데이터 개수가 많을 때(8 이상)는 Tree가 효율적이다.

### 2. Open Addressing(개방 주소법)

해시 충돌이 일어나면, 다른 해시 버킷에 삽입하는 방식이다.

다른 해시 버킷을 찾아야 하므로, 보통 Separate Chaining이 더 빠르다.

그러나 Open Addressing은 연속된 공간에 데이터를 저장하여 캐시 효율이 더 좋고, 데이터의 개수가 적을 경우에는 더 빠르다.

또한 삭제시 그냥 삭제하면 문제가 생기고, 삭제 후 더미 노드를 삽입한다.

#### 해시 버킷 탐색법

1. Linear Probing(선형 탐사): 고정 크기만큼 이동한다.
2. Quadratic Probing(제곱 탐사): 고정 크기가 아닌 제곱수로 이동한다.
3. Double Hashing(이중 해싱): 해시 함수를 한번 더 적용한다.

## Resize(동적 확장)

해시 버킷의 개수가 적다면 해시 충돌로 인해 성능상 손실이 발생한다.

그래서 key-value 쌍이 일정 개수 이상(75%) 되면 해시 버킷의 개수를 두배로 늘린다.
